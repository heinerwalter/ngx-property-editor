import { Component, Input, OnChanges, OnInit, SimpleChanges, ViewEncapsulation } from '@angular/core';
import { PEGlobalFunctions } from '../../../controller/pe-global-functions';
import { PropertyConfiguration } from '../../property-views/property-configuration';
import { TableData, TableHeader, TableRow } from '../table-configuration';
import { PropertyTableColumn } from '../property-table-column';
import { IconDefinition } from '@fortawesome/fontawesome-svg-core';
import { faColumns, faPen, faRotateBack, faSave, faTrash } from '@fortawesome/free-solid-svg-icons';
import { PropertyTableColumnController } from '../property-table-column-controller';
import { PropertyFilter, PropertyTableFilter } from '../property-table-filter';
import { PropertyTableFilterController } from '../property-table-filter-controller';

/**
 * A component displaying configured properties of multiple `data` objects as table.
 * @see PropertyConfiguration
 */
@Component({
  selector: 'pe-property-table',
  templateUrl: './property-table.component.html',
  styleUrls: ['./property-table.component.scss'],
  encapsulation: ViewEncapsulation.None,
})
export class PropertyTableComponent implements OnInit, OnChanges {

  /** ID attribute of the container element. */
  @Input() public id: string = PEGlobalFunctions.generateRandomId();

  /**
   * Configuration of displayed properties of each table entry including name,
   * data type, displayed value etc.
   */
  @Input() public configuration: PropertyConfiguration[] | undefined = undefined;

  /**
   * Display these objects in the table.
   */
  @Input() public data: any[] | undefined = undefined;

  /**
   * All columns generated from the property `configuration`
   * including currently invisible columns.
   */
  protected columns: PropertyTableColumn[] = [];

  /**
   * All currently visible columns which is a subset of `columns`.
   */
  protected visibleColumns: PropertyTableColumn[] = [];

  /**
   * Table header definition used by the <pe-table> component.
   * Generated by `generateTableHeader()`.
   */
  protected tableHeader: TableHeader = [];
  /**
   * Table data definition used by the <pe-table> component.
   * Generated by `generateTableBody()`.
   */
  protected tableData: TableData = [];

  /**
   * If true the table data can be edited by the user inside the table.
   */
  protected isEditing: boolean = false;

  // region Filter

  /**
   * If true, a filter row is displayed below the header.
   */
  @Input() public showFilterRow: boolean = true;

  /**
   * Only used if `showFilterRow` is true.
   * Filter object containing the filter expressions of all table columns.
   */
  protected filter: PropertyTableFilter = {};

  /**
   * Global filter value which is applied to any column.
   */
  protected globalFilter: string = '';

  // endregion

  /** If true, the properties displayed in the table are editable by the user. */
  @Input() public editable: boolean = false;

  // Icons used in the template
  protected iconEdit: IconDefinition = faPen;
  protected iconDelete: IconDefinition = faTrash;
  protected iconSave: IconDefinition = faSave;
  protected iconRevert: IconDefinition = faRotateBack;
  protected iconColumnChooser: IconDefinition = faColumns;

  /** This property is set to true by `ngOnInit()`. */
  private isInitialized: boolean = false;

  public constructor() {
  }

  public ngOnInit(): void {
    this.isInitialized = true;

    this.generateColumns();
  }

  public ngOnChanges(changes: SimpleChanges): void {
    // Don't generate table data for each property change before initialization is complete.
    // See ngOnInit().
    if (!this.isInitialized) return;

    if (changes.hasOwnProperty('configuration')) {
      this.generateColumns();
    }
    if (changes.hasOwnProperty('data')) {
      this.generateTableBody(this.visibleColumns);
    }
  }

  /**
   * Generates the table `columns` from the given property `configuration`.
   */
  private generateColumns(): void {
    if (!this.configuration?.length) {
      this.columns = [];
    } else {
      // Generate columns
      this.columns = PropertyTableColumnController.generateColumns(this.configuration);
    }

    this.updateVisibleColumns();
  }

  /**
   * Updates the visible columns array 
   */
  protected updateVisibleColumns(): void {
    // Generate visible columns
    this.visibleColumns = PropertyTableColumnController.generateVisibleColumns(this.columns);

    // Generate table header and body cells.
    this.generateTableHeader(this.visibleColumns);
    this.generateTableBody(this.visibleColumns);
  }

  /**
   * Generates the displayed table header data from the given `columns`.
   * @param columns The visible columns which should be displayed in the table.
   *                The `isVisible` property of the columns is ignored.
   * @see generateColumns
   * @see updateVisibleColumns
   */
  private generateTableHeader(columns: PropertyTableColumn[]): void {
    if (!columns?.length) {
      this.tableHeader = [[]];
    }

    // Compute the number of header rows based on the maximum column group depth.
    const headerRowCount: number = PropertyTableColumnController.computeMaxColumnGroupDepth(columns);

    // Initialize new table data
    const tableHeader: TableHeader = [];
    // Initialize table header rows
    for (let i = 0; i < headerRowCount; i++) {
      tableHeader.push([]);
    }

    /**
     * Generates table header cells for the given column and all of its child columns.
     * @param column The column for which the header cell should be generated.
     * @param tableHeaderRowIndex The index of the table header row into which the column should be added.
     */
    function handleColumn(
      column: PropertyTableColumn,
      tableHeaderRowIndex: number = 0
    ): void {
      // Generate a table header cell:
      tableHeader[tableHeaderRowIndex].push({
        elementType: 'header',
        content: column.property.getLabel(undefined, 'table'),
        class: 'property-table-header-cell',
        // If the column is a group, it should span all child columns.
        colspan: column.totalChildrenCount || undefined,
        // If the column is not a group, it should span all following header rows
        rowspan: !column.isGroup ? tableHeader.length - tableHeaderRowIndex : undefined,
      });

      // Add child columns, if the column is a group
      if (column.isGroup) {
        for (const child of column.children) {
          handleColumn(child, tableHeaderRowIndex + 1);
        }
      }
    }

    // Generate header:
    for (const column of columns) {
      handleColumn(column);
    }

    // Generate filter row:
    this.generateFilterRow(columns, tableHeader);

    // Assign new table data
    this.tableHeader = tableHeader;
  }

  /**
   * Generates the filter row (appended to the previously generated table
   * header data) from the given `columns`, and initializes the `filter` object
   * with empty `PropertyFilter` objects for each visible columns.
   * Already existing `PropertyFilter` objects of columns which remain visible
   * remain unchanged in the `filter` object.
   * @param columns The visible columns which should be displayed in the table.
   *                The `isVisible` property of the columns is ignored.
   * @param tableHeader The table header data to which the filter row should be appended.
   * @see generateTableHeader
   */
  private generateFilterRow(
    columns: PropertyTableColumn[],
    tableHeader: TableHeader = []
  ): void {
    if (!this.showFilterRow || !columns?.length) {
      this.filter = {};
      return;
    }
    if (!this.filter) this.filter = {};

    // Get keys of all already existing filters.
    // All filters with keys which remain in this array at the end of this method,
    // are removed from the `filter` object (related column is not visible anymore).
    const oldFilterKeys: string[] = Object.getOwnPropertyNames(this.filter || {});

    // Initialize filter row.
    const filterRow: TableRow = [];

    /**
     * (#1) Generates filter row cells,
     * (#2) adds new filters which do not exist in the `oldFilterKeys` array,
     * (#3) and removes filters which remain visible from the `oldFilterKeys` array.
     * @param column The column for which the filter row cell should be generated.
     */
    const handleColumn = (
      column: PropertyTableColumn,
    ): void => {
      if (column.isGroup) {
        for (const childColumn of column.children) {
          handleColumn(childColumn);
        }
        return;
      }

      // Generate filter key.
      const key: string = PropertyTableFilterController.generateColumnFilterKey(column.property, filterRow.length);

      // #1: Generate filter row cells.
      filterRow.push({
        elementType: 'header',
        content: this.filter,
        propertyConfiguration: new PropertyConfiguration({
          propertyName: key + '.filter',
          label: 'Filter ' + column.property.getLabel(undefined, 'table'),
          propertyType: 'string',
          editable: true,
        }),
        showPropertyInput: true,
        onPropertyInputValueChanged: () => this.onFilterChanged(),
        class: 'property-table-filter-cell',
      });

      const index: number = oldFilterKeys.indexOf(key);
      if (index < 0) {
        // #2: Add new filters which do not exist in the `oldFilterKeys` array,
        this.filter[key] = new PropertyFilter(column.property);

      } else {
        // #3: Remove filters which remain visible from the `oldFilterKeys` array.
        oldFilterKeys.splice(index, 1);
      }
    }

    // Iterate over all columns,
    // (#1) generate filter row cells
    // (#2) add new filters which do not exist in the `oldFilterKeys` array,
    // (#3) and remove filters which remain visible from the `oldFilterKeys` array.
    for (const column of columns) {
      handleColumn(column);
    }

    // Remove filters with keys which remain in the `oldFilterKeys` array.
    for (const key of oldFilterKeys) {
      delete this.filter[key];
    }

    tableHeader.push(filterRow);
  }

  /**
   * Generates the displayed table content data from the given `columns` and `this.data`.
   * @param columns The visible columns which should be displayed in the table.
   *                The `isVisible` property of the columns is ignored.
   * @see generateColumns
   * @see updateVisibleColumns
   */
  private generateTableBody(columns: PropertyTableColumn[]): void {
    if (!columns?.length) {
      this.tableData = [];
    }

    // Initialize new table data
    const tableData: TableData = [];

    /**
     * Generates table body cells for the given column and all of its child columns.
     * @param column The column for which the header cell should be generated.
     * @param tableRow The table row into which the cells should be added.
     * @param dataEntry An item of the `data` array which is displayed in the `tableRow`.
     */
    function handleColumn(
      column: PropertyTableColumn,
      tableRow: TableRow,
      dataEntry: any
    ): void {
      if (column.isGroup) {
        // Generate cells for child columns, if the column is a group
        for (const child of column.children) {
          handleColumn(child, tableRow, dataEntry);
        }

      } else {
        // Generate a table body cell
        tableRow.push({
          elementType: 'data',
          content: dataEntry,
          propertyConfiguration: column.property,
          showPropertyInput: undefined,
          class: 'property-table-data-cell',
        });
      }
    }

    // Generate body
    for (const dataEntry of this.data || []) {
      // Evaluate filter
      if (!this.evaluateFilter(columns, dataEntry)) continue;

      // Initialize new table row
      const tableRow: TableRow = [];
      // Generate cells
      for (const column of columns) {
        handleColumn(column, tableRow, dataEntry);
      }
      // Add new table row
      tableData.push(tableRow);
    }

    // Assign new table data
    this.tableData = tableData;
  }

  // region Filter

  /**
   * This method is called, when the user changed any filter value.
   */
  protected onFilterChanged(): void {
    // Re generate table data
    this.generateTableBody(this.visibleColumns);
  }

  /**
   * Evaluates the filter on the given data object (row).
   * @param columns The visible columns which should be displayed in the table.
   * @param dataEntry The data object.
   * @returns True, if the given data object should be displayed (filter is empty or matching).
   */
  private evaluateFilter(
    columns: PropertyTableColumn[],
    dataEntry: any
  ): boolean {
    // Evaluate table column filters
    if (!PropertyTableFilterController.evaluateFilters(dataEntry, this.filter))
      return false;

    // Evaluate global filter
    if (!PropertyTableFilterController.evaluateGlobalFilter(columns, dataEntry, this.globalFilter))
      return false;

    return true;
  }

  // endregion

  // region Editing

  protected startEditing(): void {
    this.isEditing = true;
  }

  protected saveChanges(): void {
    // TODO: Save changes

    this.isEditing = false;
  }

  protected revertChanges(): void {
    // TODO: Revert changes

    this.isEditing = false;
  }

  // endregion

}
