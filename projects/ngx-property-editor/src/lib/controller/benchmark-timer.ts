/*
 * File: benchmark-timer.ts
 * The BenchmarkTimer provides functionality to measure the (average) computation time of a code block.
 *
 * TypeScript implementation.
 *
 * Author: Heiner Walter
 * Year: 2023
 */

/* Add global function to write all benchmark timers to the console. */
(window as any)['logBenchmarkTimers'] = () => {
  BenchmarkTimer.writeAll();
};

/**
 * The class `BenchmarkTimer` provides functionality to measure the (average)
 * computation time of a code block.
 *
 * @example
 * // Measure time of a synchronous function:
 * BenchmarkTimer.measureExecutionTime('timer name', () => {
 *   // Measure computation time of this code block
 *   ...
 * });
 *
 * // Measure time of an asynchronous function:
 * BenchmarkTimer.measureExecutionTimeAsync('timer name', async () => {
 *   // Measure computation time of this code block
 *   await ...
 * });
 */
export class BenchmarkTimer {

  /**
   * Name of this benchmark timer to distinct measurements of different code blocks.
   * This is especially necessary if the computation time should be averaged over multiple
   * measurements which are matched by its name.
   */
  protected readonly name: string;

  /**
   * If `true` store the measured computation time and compute an average over
   * multiple measurements.
   */
  protected readonly computeAverage: boolean;

  /**
   * An additional arbitrary data object which is logged together with the benchmark timer result.
   */
  protected readonly data: any | undefined;

  /**
   * Timestamp taken when this instance was created.
   */
  private readonly startTime: DOMHighResTimeStamp;

  /**
   * Timestamp taken when the `stop()` method was called for the first time.
   */
  private endTime: DOMHighResTimeStamp | undefined = undefined;

  /**
   * Retrieves the measured computation time in milliseconds.
   */
  public get elapsedMilliseconds(): number {
    const endTime: DOMHighResTimeStamp = this.endTime == undefined ? performance.now() : this.endTime;
    return endTime - this.startTime;
  }

  /**
   * Retrieves the average measured computation time in milliseconds.
   */
  public get averageElapsedMilliseconds(): number {
    return this.averageElapsedMillisecondsAndMeasurementCount.elapsedMilliseconds;
  }

  /**
   * Retrieves the average measured computation time in milliseconds.
   */
  public get averageElapsedMillisecondsAndMeasurementCount(): { elapsedMilliseconds: number, count: number } {
    if (this.computeAverage) {
      const container = MeasurementContainer.withName(this.name);
      return {
        elapsedMilliseconds: container.averageElapsedMilliseconds,
        count: container.length,
      };
    }
    return {
      elapsedMilliseconds: this.elapsedMilliseconds,
      count: 1,
    };
  }

  /**
   * Creates a new `BenchmarkTimer` and immediately starts measuring the computation time.
   *
   * @param name Name of this benchmark timer to distinct measurements of different code blocks.
   *             This is especially necessary if the computation time should be averaged over multiple
   *             measurements which are matched by its name. If no `name` is given (`null`
   *             or empty string), no average is computed even if `computeAverage` is set to `true`.
   * @param computeAverage If this argument is set to `true` (default) the measured computation time is stored and
   *                       averaged over multiple measurements with the same `name` (e.g. for multiple iterations)
   *                       for a more significant result. If no `name` is given (`null` or empty string), no
   *                       average is computed even if `computeAverage` is set to `true`.
   * @param data An additional arbitrary data object which is logged together with the benchmark timer result.
   */
  public constructor(name: string, computeAverage: boolean = true, data: any = undefined) {
    this.name = name || '';
    this.computeAverage = this.name.length > 0 && computeAverage;
    this.data = data;

    this.startTime = performance.now();
  }

  /**
   * Stop the benchmark timer. Afterwards the measured computation time is available via
   * `elapsedMilliseconds` and the averaged computation time
   * (if activated) via `averageElapsedMilliseconds`.
   */
  public stop(): void {
    // Don't stop the same timer twice
    if (this.endTime != undefined)
      return;

    this.endTime = performance.now();

    if (this.computeAverage) {
      MeasurementContainer.addMeasurementWithName(this.name, this.elapsedMilliseconds);
    }
  }

  /**
   * Write the measured computation time (and average computation time if activated) to the console.
   * Before calling this function the timer should be stopped (see `stop()`).
   * The written line is generated by `toString()`.
   * @see toString
   * @see stopAndWrite
   */
  public write(): void {
    if (this.data)
      console.log(this.toString(), this.data);
    else
      console.log(this.toString());
  }

  /**
   * Stop the timer (see `stop()`) and write the measured computation time
   * (and average computation time if activated) to the console (see `write()`).
   * The written line is generated by `toString()`.
   * @see stop
   * @see write
   */
  public stopAndWrite(): void {
    this.stop();
    this.write();
  }

  /**
   * Generates a string containing the timer `name`, the measured
   * computation time and the average computation time (if activated).
   *
   * @example
   * // Example format:
   * "BENCHMARK: Example code block: 10 ms (average: 9.7 ms)"
   *
   * @returns Name and measured computation time (+average) as human-readable string.
   */
  public toString(): string {
    if (this.computeAverage) {
      const average = this.averageElapsedMillisecondsAndMeasurementCount;
      return `BENCHMARK: ${ this.name }: ${ timeToString(this.elapsedMilliseconds) } (average of ${ average.count }: ${ timeToString(average.elapsedMilliseconds) })`;
    }

    return `BENCHMARK: ${ this.name }: ${ timeToString(this.elapsedMilliseconds) }`;
  }

  /**
   * Measures the execution time of the given `action` function and writes the time to the console.
   * @param name Name of this benchmark timer to distinct measurements of different code blocks.
   *             This is especially necessary if the computation time should be averaged over multiple
   *             measurements which are matched by its name. If no `name` is given (`null`
   *             or empty string), no average is computed even if `computeAverage` is set to `true`.
   * @param action Measure execution time of this function.
   * @see measureExecutionTimeAsync
   */
  public static measureExecutionTime<T>(name: string, action: () => T): T {
    const timer = new BenchmarkTimer(name);
    try {
      return action();
    } finally {
      timer.stopAndWrite();
    }
  }

  /**
   * Measures the execution time of the given asynchronous `action` function and writes the time to the console.
   * @param name Name of this benchmark timer to distinct measurements of different code blocks.
   *             This is especially necessary if the computation time should be averaged over multiple
   *             measurements which are matched by its name. If no `name` is given (`null`
   *             or empty string), no average is computed even if `computeAverage` is set to `true`.
   * @param action Measure execution time of this asynchronous function.
   * @see measureExecutionTime
   */
  public static async measureExecutionTimeAsync<T>(name: string, action: () => Promise<T>): Promise<T> {
    const timer = new BenchmarkTimer(name);
    try {
      return await action();
    } finally {
      timer.stopAndWrite();
    }
  }

  /**
   * Gets a string containing the average computation time (`averageElapsedMilliseconds`)
   * of all registered `BenchmarkTimer`s.
   *
   * @example
   * // Format of the returned string (one BenchmarkTimer per line):
   * BENCHMARK: Name_1: 12 ms
   * BENCHMARK: Name_2: 42 ms
   *
   * @returns A `string` with the `averageElapsedMilliseconds` of each registered `BenchmarkTimer` (one per line).
   */
  public static allToString(): string {
    return MeasurementContainer.allMeasurementsToString();
  }

  /**
   * Write the average computation time (`averageElapsedMilliseconds`) of all registered
   * `BenchmarkTimer`s. The written text is generated by `allToString()`.
   * @see allToString
   */
  public static writeAll(): void {
    console.log(this.allToString());
  }

}

/**
 * A container to store multiple measured computation times of the same code block (same
 * `name` which is used to compute the average computation time.
 */
class MeasurementContainer {

  /**
   * Storage of computation time measurements.
   * @see addMeasurement
   */
  private readonly elapsedMillisecondsList: number[] = [];

  /**
   * Add a new computation time measurement to this container.
   * @param elapsedMilliseconds The measured computation time in milliseconds.
   */
  public addMeasurement(elapsedMilliseconds: number): void {
    this.elapsedMillisecondsList.push(elapsedMilliseconds);
  }

  /**
   * Retrieves the number of measurements which are stored in this container.
   */
  public get length(): number {
    return this.elapsedMillisecondsList.length;
  }

  /**
   * Retrieves the average computation time in milliseconds over all measurements
   * which are stored in this container.
   */
  public get averageElapsedMilliseconds(): number {
    if (this.elapsedMillisecondsList.length == 0)
      return 0;
    return MeasurementContainer.average(this.elapsedMillisecondsList);
  }

  /**
   * Computes the arithmetic mean of all values of an array.
   * @param array An array of numbers.
   */
  private static average(array: number[]): number {
    if (!array?.length) return 0;
    return array.reduce((item, sum) => sum + item, 0) / array.length;
  }

  /**
   * Static storage of all measurements grouped by the `BenchmarkTimer.name`.
   */
  private static readonly map: { [key: string]: MeasurementContainer } = {};

  /**
   * Gets a string containing the average computation time (`AverageElapsedMilliseconds`)
   * of all registered `MeasurementContainer`s.
   *
   * @example
   * // Format of the returned string (one BenchmarkTimer per line):
   * BENCHMARK: Name_1: 12 ms
   * BENCHMARK: Name_2: 42 ms
   * @returns A string with the `averageElapsedMilliseconds` of each registered `BenchmarkTimer` (one per line).
   * @see map
   */
  public static allMeasurementsToString(): string {
    let output: string = '';
    for (let key in this.map) {
      if (!this.map.hasOwnProperty(key)) continue;
      const value: MeasurementContainer = this.map[key];
      output += `BENCHMARK: ${ key }: ${ timeToString(value.averageElapsedMilliseconds) }\n`;
    }

    return output;
  }

  /**
   * Retrieves the `MeasurementContainer` which is`mapped to the given benchmark
   * timer `name` or creates a new and empty one if it doesn't exist yet.
   * @param name The `BenchmarkTimer.name`.
   * @returns The `MeasurementContainer` with the computation time measurements of the
   *          `BenchmarkTimer` with the given `name`.
   */
  public static withName(name: string): MeasurementContainer {
    if (!this.map.hasOwnProperty(name)) {
      const container = new MeasurementContainer();
      this.map[name] = container;
      return container;
    }
    return this.map[name];
  }

  /**
   * Add a new measurement to the `MeasurementContainer` which is mapped to the given
   * benchmark timer `name`. If the container with this `name` doesn't exist yet
   * a new one is created.
   * @param name The `BenchmarkTimer.name`.
   * @param elapsedMilliseconds The measured computation time in milliseconds.
   */
  public static addMeasurementWithName(name: string, elapsedMilliseconds: number): void {
    const container: MeasurementContainer = this.withName(name);
    container.addMeasurement(elapsedMilliseconds);
    this.map[name] = container;
  }

}

/**
 * Generates a string representation of a time given in milliseconds.
 * @param milliseconds Time in milliseconds.
 * @returns A string representation in seconds of the given time (e.g. "1.234 s").
 */
function timeToString(milliseconds: number): string {
  // Write as milliseconds
  //return `${ Math.round(milliseconds) } ms`;
  // Write as seconds
  return `${ (milliseconds / 1000).toFixed(3) } s`;
}
